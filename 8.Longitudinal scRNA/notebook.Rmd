---
title: "Running LACE framework on real data"
output: 
  html_document:
    df_print: paged
editor_options: 
  chunk_output_type: inline
---

We are going to apply LACE to a PDX of BRAF-mutated melanoma longitudinal single cell RNA-seq data.

These data are published in a paper called "Toward minimal residual disease-directed therapy in melanoma" by Florian Rambow and collegues (VIB Center for Cancer Biology, Belgium) accessible [here](https://doi.org/10.1016/j.cell.2018.06.025).

Single-cells were isolated and sequenced via scRNA-seq at four subsequent time points:

-   T0) before treatment (n = 146 single cells);

-   T1) after 4 days of concurrent treatment with BRAF inhibitor (i.e, dabrafenib) and MEK inhibitor (i.e, trametinib) (n = 111),

-   T2) after 28 days of treatment (n = 90),

-   T3) after 57 days of treatment (n = 128).

Sequencing data (FASTQ format) were uploaded into [GEO database](https://www.ncbi.nlm.nih.gov/geo/GSE116237) using the following access number: GSE116237. By running *SRA Run Selector* [here](https://www.ncbi.nlm.nih.gov/Traces/study/?acc=PRJNA477841&o=acc_s%3Aa) we can obtain cell metadata and download the proper sequences.

## STEP 1 - Variant calling

The execution of this part is omitted here, but the pipeline code is provided in the *LACEpipeline.sh* bash file.

The pipeline uses different tools to perform the following steps:

-   *Trimmomatic*: Trim fastq file to remove bases with poor sequencing quality and adapters (if necessary)

-   *STAR*: Align the reads respect to a reference genome (Homo_sapiens.GRCh38.dna_sm.primary_assembly.fa)

-   *Picard / GATK*:

    -   Mark duplicate reads

    -   Handle reads near splicing events (*SplitNCigarReads*, *BaseRecalibrator)*

    -   *PrintReads* to obtain the final BAM files.

-   *HaplotypeCaller:* Detect SNPs and SNVs from the RNA sequencing reads

-   \*Annovar\*: Add useful information to each mutation:

    -   Genomic region (exonic or intronic)

    -   Mutation type (Synonymous, Non-Syn, insertion, deletion, stop-gain, stop-loss)

    -   If it is a known mutation the corresponding RS_ID is retrieved together with additional info such as the Minor Allele Frequency (MAF).

## STEP 2 - Exploration of called single cell mutations

The following code starts from the results by ANNOVAR generated by LACEpipeline.sh

LACE infers the clonal evolution considering driver events, so mutations found have to be filtered to select a *small* SNV subset enriched with driver mutations.

First of all, we aggregate all the mutations in one data.frame:

So, we get the list of files to be considered and cells metadata

```{r message=FALSE, warning=FALSE}
unzip("Melanoma/preprocessing/annotated/exonic_variant_function.zip", 
      overwrite = FALSE, 
      exdir = "Melanoma/preprocessing/annotated/exonic_variant_function")
listSC <- dir(path = "Melanoma/preprocessing/annotated/exonic_variant_function/", pattern=".exonic_variant_function",
              ignore.case=TRUE, 
              full.names = F)
cellInfo <- readRDS("Melanoma/preprocessing/metadata/data_info.rds")
```

Create data structure to save the results

```{r}
tbFinal <- setNames(data.frame(matrix(ncol=12,nrow=0)), c("scID","Time","Gene","Chr","PosStart","PosEnd","REF","ALT","MutType","rs_ID","depth","Allele_Ratio"))
cn <- colnames(tbFinal)
```

Process each single cell

```{r echo=TRUE, warning=FALSE}

library("progress")
# consider each cell
setwd("Melanoma/preprocessing/annotated/exonic_variant_function/")
cont <- 0
pb <- progress_bar$new(total = length(listSC))
tbFinal <- data.frame()
for(sc in listSC) {
    
    # get current cell name
    run <- strsplit(x = sc, split = "\\.")[[1]][1]
    
    # read vcf annotated by ANNOVAR for current cell
    tmpTbl <- read.table(file = sc, header = FALSE, sep = "\t", stringsAsFactors = FALSE)
    tmpTbl$scID <- run
    
    # get information about time of experiment
    tmpTime <- as.character(cellInfo$Age[cellInfo$Run==run])
    tmpTbl$Time <- tmpTime
    
    # get genes names
    tmpTbl$V3 <- sapply(as.character(tmpTbl$V3), function(x){strsplit(x, ":")[[1]][1]})
    
    # get the remaining information
    OtherInfo <- tmpTbl[, "V18"]
    tmpTbl <- tmpTbl[, c("scID", "Time", "V3", "V4", "V5", "V6", "V7", "V8", "V2", "V11")]
    colnames(tmpTbl) <- c("sc_ID", "Time", "Gene", "Chr", "PStart", "PEnd", "Ref", "Alt", "Mut_type", "RS_id")
    
    # extract quality and coverage information
    
    #Example
    #GT   : AD  : DP :  GQ :  PL	
    #0/1  : 2,4 : 6  :  50 :  107,0,50
    
    #GT = genotype
    #AD = Allele depth (for each allele)
    #DP = Total depth
    #GQ = Conditional genotype quality
    #PL = Phred-scaled genotype likelihoods rounded to the closest integer
    # for additional info about GQ and PL see: 
    # https://gatk.broadinstitute.org/hc/en-us/articles/360035890451-Calculation-of-PL-and-GQ-by-HaplotypeCaller-and-GenotypeGVCFs
    
    for(m in 1:length(OtherInfo)) {
        
        info <- unlist(strsplit(OtherInfo[m],":"))
        
        if(length(info) < 5) {
            depth <- NA
            RA <- NA
        }
        else {
            RefAlt <- unlist(strsplit(info[2], ","))
            depth <- sum(as.numeric(RefAlt))
            if(depth == 0) {
                RA <- NA
                }
            else {
                RA <- as.numeric(RefAlt[2])
            }
        }
        tmpTbl$depth[m] <- depth
        tmpTbl$Allele_Ratio[m] <- RA
        
    }
    
    # save results for current cell
    colnames(tmpTbl) <- cn
    tbFinal <- rbind(tbFinal,tmpTbl)
    
    pb$tick()
    
}
tbFinal$UIDsnp <- paste0(tbFinal$Gene,"_",tbFinal$Chr,"_",tbFinal$PosStart,ifelse(tbFinal$rs_ID == '.', "", paste0("_",tbFinal$rs_ID)))

saveRDS(tbFinal, file = "../../cells_aggregate_info.rds")

cat("Total number of single cells: ", length(listSC), "\n")

cat("Total number of SNVs: ", nrow(tbFinal), " of which ", length(unique(tbFinal$UIDsnp)), "are distinct\n")

hist(table(tbFinal$scID), breaks = 50, xlab = "# mutations", main = "Distribution of mutations", ylab = "# of single cells")
```

#### Step 2a - Mutation filter

Now, we remove mutations with *synonymous* or *unknown* function to keep only SNVs that are more likely to be driver events.

```{r}
tbFinal <- readRDS(file=paste0("Melanoma/preprocessing/cells_aggregate_info.rds"))
tbFinal <- tbFinal[tbFinal$MutType!="synonymous SNV"& tbFinal$MutType!="unknown",]
saveRDS(tbFinal, file = "Melanoma/preprocessing/cells_aggregate_info_filt.rds")

cat("Total number of SNVs: ", nrow(tbFinal), " of which ", length(unique(tbFinal$UIDsnp)), "are distinct\n")

```

Then, we add information obtained from public database (ENSEMBLE) such as MAF (minor allele frequency) and clinical relevance.

```{r message=FALSE, warning=FALSE}
library("biomaRt")
u_rsID <- as.character(unique(tbFinal$rs_ID[startsWith(as.character(tbFinal$rs_ID),prefix="rs")]))

ensembl_snp = useMart("ENSEMBL_MART_SNP",dataset="hsapiens_snp")
SNPInfo <- getBM(attributes=c("refsnp_id",
                              "minor_allele",
                              "minor_allele_freq",
                              "polyphen_prediction",
                              "sift_prediction",
                              "clinical_significance"),
                 filters = "snp_filter",
                 values = u_rsID,
                 mart = ensembl_snp)

scMutInfo <- merge.data.frame(tbFinal, SNPInfo, by.x = "rs_ID", by.y = "refsnp_id", all.x = TRUE, all.y = TRUE)

saveRDS(SNPInfo,file=paste0("Melanoma/preprocessing/SNPInfo.rds"))
saveRDS(scMutInfo,file=paste0("Melanoma/preprocessing/scMutInfo.rds"))

```

```{r}

tbFinal <- readRDS("Melanoma/preprocessing/cells_aggregate_info_filt.rds")
SNPInfo <- readRDS("Melanoma/preprocessing/SNPInfo.rds")

scMutInfo <- merge.data.frame(tbFinal, SNPInfo, by.x = "rs_ID", by.y = "refsnp_id", all.x = TRUE, all.y = TRUE)

saveRDS(scMutInfo,file=paste0("Melanoma/preprocessing/scMutInfo.rds"))
```

We perform the final filtering steps by removing mutations with

-   less then *thr_alleles_reads* reads of support

-   MAF greater then *thr_maf* (they are likely SNPs)

First, we setup the filtering parameters

```{r}
thr_alleles_reads <- 2
thr_maf <- 0.01

```

```{r}
scMutInfo <- readRDS(file=paste0("Melanoma/preprocessing/scMutInfo.rds"))

scMutInfo <- scMutInfo[((!is.na(scMutInfo$Allele_Ratio)) & (scMutInfo$Allele_Ratio >= thr_alleles_reads)),]

mutWOrs <- scMutInfo[scMutInfo$rs_ID == ".", ]
mutWrs <- scMutInfo[scMutInfo$rs_ID != ".", ]

FilterMutations <- function(sc_r) {
    
    # if not a snp, keep it
    if(sc_r["rs_ID"] == ".") {
        return(TRUE)
    }
    
    # filter using MAF
    if(sc_r["minor_allele"] == sc_r["ALT"] && sc_r["minor_allele_freq"] > thr_maf) {
        return(FALSE)
    }
    else if(sc_r["minor_allele"] == sc_r["REF"] && sc_r["minor_allele_freq"] < (1-thr_maf)) {
        return(FALSE)
    }
    
    return(TRUE)
    
}
mut_to_keep <- apply(X = mutWrs, MARGIN = 1, FUN = function(x) FilterMutations(x))

mutWrs_filt <- mutWrs[mut_to_keep,]
snpMut_filt <- rbind(mutWOrs, mutWrs_filt)

saveRDS(snpMut_filt,file=paste0("Melanoma/preprocessing/snpMut_filt.rds"))

```

Finally, we generate a matrix with cells on rows and mutations on columns. The aim is to remove SNVs observed with a frequency lower than *thr_freq* in all the 4 time points.

While we do this, we remove cells that don't pass quality check performed by the authors of the dataset.

```{r}
thr_freq <- 0.05

snpMut_filt <- readRDS(file=paste0("Melanoma/preprocessing/snpMut_filt.rds"))

# consider only cells passing quality checks
valid_clones_mapping <- read.table(file = "Melanoma/downstreamAnalysis/RUNmetadata.txt", 
                                   header = T, 
                                   sep = '\t')

snpMut_filt = snpMut_filt[which(snpMut_filt$scID%in%valid_clones_mapping$Run),]

tblscMut_T1 <- table(snpMut_filt$scID[snpMut_filt$Time == "before treatment"], snpMut_filt$UIDsnp[snpMut_filt$Time == "before treatment"])
tblscMut_T2 <- table(snpMut_filt$scID[snpMut_filt$Time == "4d on treatment"], snpMut_filt$UIDsnp[snpMut_filt$Time == "4d on treatment"])
tblscMut_T3 <- table(snpMut_filt$scID[snpMut_filt$Time == "28d on treatment"], snpMut_filt$UIDsnp[snpMut_filt$Time == "28d on treatment"])
tblscMut_T4 <- table(snpMut_filt$scID[snpMut_filt$Time == "57d on treatment"], snpMut_filt$UIDsnp[snpMut_filt$Time == "57d on treatment"])

# binarization
tblscMut_T1[which(tblscMut_T1 > 0)] <- 1
tblscMut_T2[which(tblscMut_T2 > 0)] <- 1
tblscMut_T3[which(tblscMut_T3 > 0)] <- 1
tblscMut_T4[which(tblscMut_T4 > 0)] <- 1

Mut_keep = c()

cs <- colSums(tblscMut_T1, na.rm = TRUE) / nrow(tblscMut_T1)
Mut_keep = c(Mut_keep, colnames(tblscMut_T1)[cs > thr_freq])
cs <- colSums(tblscMut_T2, na.rm = TRUE) / nrow(tblscMut_T2)
Mut_keep = c(Mut_keep, colnames(tblscMut_T2)[cs > thr_freq])
cs <- colSums(tblscMut_T3, na.rm = TRUE) / nrow(tblscMut_T3)
Mut_keep = c(Mut_keep, colnames(tblscMut_T3)[cs > thr_freq])
cs <- colSums(tblscMut_T4, na.rm = TRUE) / nrow(tblscMut_T4)
Mut_keep = c(Mut_keep, colnames(tblscMut_T4)[cs > thr_freq])

snpMut_filt_freq <- snpMut_filt[snpMut_filt$UIDsnp %in% Mut_keep,]

cat("Total number of single cells after preprocessing: ", length(unique(snpMut_filt_freq$scID)), "\n")

cat("Total number of SNVs after preprocessing: ", nrow(snpMut_filt_freq), " of which ", length(unique(snpMut_filt_freq$UIDsnp)), "are distinct\n")

hist(table(snpMut_filt_freq$scID), breaks = 50, xlab = "# mutations", main = "Distribution of mutations after preprocessing", ylab = "# of single cells")

saveRDS(snpMut_filt_freq,file=paste0("Melanoma/preprocessing/snpMut_filt_freq.rds"))

```

#### Step 2b - Get depth information

This step will be skipped due to a time constraint. Anyway, we used \<samtools depth\> to get the depth information for each mutation in each single cell and generate two matrices.

1.  "final_data_mut.txt" contains a binary matrix in which 1 indicates the presence of a mutation in a given cell, while 0 indicates absence.

2.  "final_data_depth.txt" contains an integer matrix *mutations-x-cell* with the information on the number of reads aligned over that position in each single cell.

#### Step 2c - Explore LACE input data

We reached the last filtering step. Now we will assign a *NA* value *(missing information)* to each mutation covered with less than *depth_minimum* reads.

Then, we will filter out the mutations that show a number of NA higher than *missing_values_max*

```{r}
# Setting up variables
depth_minimum = 3 # minimum depth to set values to NA
missing_values_max = 0.40 # maximum number of considered missing data per gene
```

Load mutations and depth matrices

```{r}
snpMut_filt_freq <- readRDS(file="Melanoma/preprocessing/snpMut_filt_freq.rds")
mutations = as.matrix(read.table("Melanoma/preprocessing/depth/final_data_depth.txt"))
depth = as.matrix(read.table("Melanoma/preprocessing/depth/final_data_depth.txt"))

depth = depth[,colnames(mutations)]
mutations[which(mutations>1,arr.ind=TRUE)] = 1

```

Replace 0/1 with NA if the depth of a mutation in a single cell is less than or equal to *depth_minimum* and count the number of missing data per time point

```{r}
mutations[which(depth<=depth_minimum,arr.ind=TRUE)] = NA


mycellsdata = list()
mycellsdata[["T1_before_treatment"]] = t(mutations[,sort(unique(snpMut_filt_freq$scID[which(snpMut_filt_freq$Time=="before treatment")]))])
mycellsdata[["T2_4_days_treatment"]] = t(mutations[,sort(unique(snpMut_filt_freq$scID[which(snpMut_filt_freq$Time=="4d on treatment")]))])
mycellsdata[["T3_28_days_treatment"]] = t(mutations[,sort(unique(snpMut_filt_freq$scID[which(snpMut_filt_freq$Time=="28d on treatment")]))])
mycellsdata[["T4_57_days_treatment"]] = t(mutations[,sort(unique(snpMut_filt_freq$scID[which(snpMut_filt_freq$Time=="57d on treatment")]))])


t1 = NULL
t2 = NULL
t3 = NULL
t4 = NULL

nMut = nrow(mutations)

for(i in 1:nMut) {
    t1 = c(t1,sum(is.na(mycellsdata[["T1_before_treatment"]][,i])) / 
             nrow(mycellsdata[["T1_before_treatment"]]))
    
    t2 = c(t2,sum(is.na(mycellsdata[["T2_4_days_treatment"]][,i])) / 
             nrow(mycellsdata[["T2_4_days_treatment"]]))
    
    t3 = c(t3,sum(is.na(mycellsdata[["T3_28_days_treatment"]][,i])) / 
             nrow(mycellsdata[["T3_28_days_treatment"]]))
    
    t4 = c(t4,sum(is.na(mycellsdata[["T4_57_days_treatment"]][,i])) / 
             nrow(mycellsdata[["T4_57_days_treatment"]]))
}

```

Then, keep in *valid_positions* only SNVs that satisfy the maximum number of NA allowed in every time point

```{r}
valid_positions = sort(unique(rownames(mutations)[which(t1<=missing_values_max & 
                                                      t2<=missing_values_max &
                                                      t3<=missing_values_max &
                                                      t4<=missing_values_max)
                                              ]
                          )
                   )

valid_genes = NULL
for(vp in valid_positions) {
    valid_genes = c(valid_genes,unique(snpMut_filt_freq$Gene[grep(vp,snpMut_filt_freq$UIDsnp)]))
}
valid = paste0(valid_genes,"_",valid_positions)
```

Finally, we apply the filter by keeping only valid mutations to obtain a list of candidate selected SNVs

```{r}
snpMut_filt_freq_reduced = unique(snpMut_filt_freq[which(snpMut_filt_freq$Gene%in%valid_genes),c("Gene","Chr","PosStart","PosEnd","REF","ALT")])

snpMut_filt_freq_reduced = snpMut_filt_freq_reduced[order(snpMut_filt_freq_reduced[,1],snpMut_filt_freq_reduced[,2],snpMut_filt_freq_reduced[,3],snpMut_filt_freq_reduced[,4],snpMut_filt_freq_reduced[,5],snpMut_filt_freq_reduced[,6]),]

write.table(snpMut_filt_freq_reduced,file="Melanoma/preprocessing/snpMut_filt_freq_reduced.txt",append=FALSE,quote=FALSE,sep="\t",row.names=FALSE,col.names=TRUE)

cat("We have ", length(valid_genes), " valid positions of which ", length(unique(valid_genes)), " are distinct\n")

cat("We have also ", sum(duplicated(valid_genes)), " positions mutated more than once\n")

```

#### Step 2d - Create the input for LACE

Since now, we used automatic filters without any biological knowledge. To further reduce the number of SNVs included in the inference we select a subset of them by searching in the literature which genes are the most relevant in melanoma diseases.

```{r}

verified_genes = c("ARPC2","CCT8","COL1A2","CYCS","HNRNPC","PCBP1","PRAME","RPL5")

```

Setting up parameteres..

```{r}

depth_minimum = 3 # minimum depth to set values to NA
minumum_median_total = 10 # minimum median depth for total reads
minumum_median_mutation = 4 # minimum median depth for reads supporting mutations

```

... and load data

```{r}
cells_aggregate_info <- readRDS(file = "Melanoma/preprocessing/cells_aggregate_info.rds")
snpMut_filt_freq <- readRDS(file = "Melanoma/preprocessing/snpMut_filt_freq.rds")
depth = as.matrix(read.table("Melanoma/preprocessing/depth/final_data_depth.txt"))
```

We keep only mutations that hit relevant genes

```{r}

snpMut_filt_freq = snpMut_filt_freq[which(snpMut_filt_freq$Gene%in%verified_genes),
                                    c("scID","Time","Gene","Chr","PosStart","PosEnd","REF","ALT","MutType","depth","Allele_Ratio")]

snpMut_filt_freq = snpMut_filt_freq[order(snpMut_filt_freq[,3],
                                          snpMut_filt_freq[,4],
                                          snpMut_filt_freq[,5],
                                          snpMut_filt_freq[,6],
                                          snpMut_filt_freq[,7],
                                          snpMut_filt_freq[,8],
                                          snpMut_filt_freq[,9],
                                          snpMut_filt_freq[,1],
                                          snpMut_filt_freq[,2],
                                          snpMut_filt_freq[,10],
                                          snpMut_filt_freq[,11])
                                    ,]


```

Compute frequency of each selected mutation

```{r}

distinct_mutations = unique(data.frame(Gene = snpMut_filt_freq$Gene, 
                                Chr = snpMut_filt_freq$Chr, 
                                PosStart = snpMut_filt_freq$PosStart, 
                                PosEnd = snpMut_filt_freq$PosEnd, 
                                REF = snpMut_filt_freq$REF, 
                                ALT = snpMut_filt_freq$ALT, 
                                FreqT1 = NA,
                                FreqT2 = NA,
                                FreqT3 = NA,
                                FreqT4 = NA,
                                MedianDepth = NA,
                                MedianDepthMut = NA)
                            )

cells_timepoints = unique(snpMut_filt_freq[,c("scID","Time")])

t1 = as.numeric(table(cells_timepoints$Time)["before treatment"])
t2 = as.numeric(table(cells_timepoints$Time)["4d on treatment"])
t3 = as.numeric(table(cells_timepoints$Time)["28d on treatment"])
t4 = as.numeric(table(cells_timepoints$Time)["57d on treatment"])

for(i in 1:nrow(distinct_mutations)) {
  
  curr = snpMut_filt_freq[which(snpMut_filt_freq$Gene%in%distinct_mutations[i,"Gene"] & 
                                  snpMut_filt_freq$Chr%in%distinct_mutations[i,"Chr"] & 
                                  snpMut_filt_freq$PosStart%in%distinct_mutations[i,"PosStart"] &
                                  snpMut_filt_freq$PosEnd%in%distinct_mutations[i,"PosEnd"] &
                                  snpMut_filt_freq$REF%in%distinct_mutations[i,"REF"] &
                                  snpMut_filt_freq$ALT%in%distinct_mutations[i,"ALT"]),]
    
    distinct_mutations[i,"FreqT1"] = as.numeric(table(curr$Time)["before treatment"]) / t1
    distinct_mutations[i,"FreqT2"] = as.numeric(table(curr$Time)["4d on treatment"]) / t2
    distinct_mutations[i,"FreqT3"] = as.numeric(table(curr$Time)["28d on treatment"]) / t3
    distinct_mutations[i,"FreqT4"] = as.numeric(table(curr$Time)["57d on treatment"]) / t4
    
    distinct_mutations[i,"MedianDepth"] = as.numeric(median(curr$depth))
    distinct_mutations[i,"MedianDepthMut"] = as.numeric(median(curr$Allele_Ratio))
}

# Remove indels
distinct_mutations = distinct_mutations[distinct_mutations$REF != '-',]


# Filtering mutations based on 
distinct_mutations = distinct_mutations[-sort(unique(c(which(distinct_mutations$MedianDepth<minumum_median_total),
                                                       which(distinct_mutations$MedianDepthMut<minumum_median_mutation)))),]

rownames(distinct_mutations) = 1:nrow(distinct_mutations)

valid_distinct_mutations = distinct_mutations
valid_distinct_mutations_values = NULL

for(i in 1:nrow(valid_distinct_mutations)) {
    valid_distinct_mutations_values = c(valid_distinct_mutations_values,
                                        paste0(valid_distinct_mutations[i,c("Chr","PosStart")],collapse="_"))
}

saveRDS(valid_distinct_mutations,file="Melanoma/preprocessing/valid_distinct_mutations.rds")

print(valid_distinct_mutations)
```

We can now generate the input for LACE:

```{r}

# Initialize cells x mutations matrix
mutations = array(0,c(length(unique(valid_clones_mapping$Run)),6))

rownames(mutations) = sort(unique(valid_clones_mapping$Run))

colnames(mutations) = paste0(valid_distinct_mutations$Gene,
                             "_",
                             valid_distinct_mutations_values,
                             "_",
                             valid_distinct_mutations$REF,
                             "_",
                             valid_distinct_mutations$ALT)

for(i in 1:nrow(valid_distinct_mutations)) {
  
    curr_gene = valid_distinct_mutations[i,"Gene"]
    curr_chr = valid_distinct_mutations[i,"Chr"]
    curr_start = valid_distinct_mutations[i,"PosStart"]
    curr_end = valid_distinct_mutations[i,"PosEnd"]
    curr_ref = valid_distinct_mutations[i,"REF"]
    curr_alt = valid_distinct_mutations[i,"ALT"]
    
    curr_mutant_cells = which(cells_aggregate_info$Gene==curr_gene & 
                                cells_aggregate_info$Chr==curr_chr & 
                                cells_aggregate_info$PosStart==curr_start & 
                                cells_aggregate_info$PosEnd==curr_end & 
                                cells_aggregate_info$REF==curr_ref & 
                                cells_aggregate_info$ALT==curr_alt)
    
    curr_mutant_cells = cells_aggregate_info$scID[curr_mutant_cells]
    
    mutations[curr_mutant_cells[which(curr_mutant_cells%in%rownames(mutations))],i] = 1
}

# set NA values
depth = t(depth)
depth = depth[,valid_distinct_mutations_values]
depth = depth[rownames(mutations),]
colnames(depth) = colnames(mutations)
mutations[which(depth<=depth_minimum,arr.ind=TRUE)] = NA # missing values rate equals to 359/2850, that is approx 12.6%


# make final data
cells_aggregate_info = cells_aggregate_info[which(cells_aggregate_info$scID%in%rownames(mutations)),]
mycellsdata = list()
mycellsdata[["T1_before_treatment"]] = mutations[sort(unique(cells_aggregate_info$scID[which(cells_aggregate_info$Time=="before treatment")])),]
mycellsdata[["T2_4_days_treatment"]] = mutations[sort(unique(cells_aggregate_info$scID[which(cells_aggregate_info$Time=="4d on treatment")])),]
mycellsdata[["T3_28_days_treatment"]] = mutations[sort(unique(cells_aggregate_info$scID[which(cells_aggregate_info$Time=="28d on treatment")])),]
mycellsdata[["T4_57_days_treatment"]] = mutations[sort(unique(cells_aggregate_info$scID[which(cells_aggregate_info$Time=="57d on treatment")])),]
D = mycellsdata

saveRDS(D,file="Melanoma/LACEinput/D.rds")

```

Before starting the inference we plot an oncoprint to take a look to the mutation distributions

```{r message=FALSE, warning=FALSE}

library("TRONCO")

# make Oncoprint
clusters = array(NA,c((nrow(D[[1]])+nrow(D[[2]])+nrow(D[[3]])+nrow(D[[4]])),1))
clusters[1:nrow(D[[1]]),1] = "T1_before_treatment"
clusters[(nrow(D[[1]])+1):(nrow(D[[1]])+nrow(D[[2]])),1] = "T2_4_days_treatment"
clusters[(nrow(D[[1]])+nrow(D[[2]])+1):(nrow(D[[1]])+nrow(D[[2]])+nrow(D[[3]])),1] = "T3_28_days_treatment"
clusters[(nrow(D[[1]])+nrow(D[[2]])+nrow(D[[3]])+1):(nrow(D[[1]])+nrow(D[[2]])+nrow(D[[3]])+nrow(D[[4]])),1] = "T4_57_days_treatment"
rownames(clusters) = c(rownames(D[[1]]),rownames(D[[2]]),rownames(D[[3]]),rownames(D[[4]]))
data = rbind(D[[1]],D[[2]],D[[3]],D[[4]])
data[which(is.na(data))] = 0
data = import.genotypes(data)
data = annotate.stages(data,clusters)
oncoprint(data,excl.sort=FALSE,group.by.stage=TRUE)
```

## STEP 3 - Running LACE to inference the Melanoma evolution

LACE takes in input the binary matrix (cells x mutations) for each time point.

```{r}
D <- readRDS("Melanoma/LACEinput/D.rds")
seed=35
```

LACE requires also some parameters.

1.  We have to define weights based on the number of single cell included in each time point in order to normalize the log-likelihood values.

```{r}

lik_w1 = (1-(dim(D[[1]])[1]/(dim(D[[1]])[1]+dim(D[[2]])[1]+dim(D[[3]])[1]+dim(D[[4]])[1])))
lik_w2 = (1-(dim(D[[2]])[1]/(dim(D[[1]])[1]+dim(D[[2]])[1]+dim(D[[3]])[1]+dim(D[[4]])[1])))
lik_w3 = (1-(dim(D[[3]])[1]/(dim(D[[1]])[1]+dim(D[[2]])[1]+dim(D[[3]])[1]+dim(D[[4]])[1])))
lik_w4 = (1-(dim(D[[4]])[1]/(dim(D[[1]])[1]+dim(D[[2]])[1]+dim(D[[3]])[1]+dim(D[[4]])[1])))
lik_w = c(lik_w1,lik_w2,lik_w3,lik_w4)
lik_w = lik_w/sum(lik_w)
```

2.  We have to propose alpha (False Positive) and Beta (False Negative) values. There are different methods to define them, we used a grid search: different values are tried in independent runs.

    Here, we try only one set of parameters.

```{r}
alpha <- list(c(0.05,0.05,0.05,0.05))
beta <- list(c(0.15,0.15,0.15,0.15))
```

We can now run the inference

```{r message=FALSE, warning=FALSE}
library("LACE")
library("parallel")
library("Rfast")

#First, we replace the mutation IDs keeping only the gene name
Genes <- sapply(X = colnames(D[[1]]), FUN = function(x) {strsplit(x = x, split = '_')[[1]][1]}, USE.NAMES = F)

for(i in 1:length(D)) {
  colnames(D[[i]]) <- Genes
}

inference = LACE(D=D,
                 lik_w=lik_w,
                 alpha=alpha,
                 beta=beta,
                 num_rs=4,
                 num_iter=Inf,
                 n_try_bs=1000,
                 marginalize=FALSE,
                 num_processes=4,
                 seed=125,
                 verbose=TRUE, 
                 initialization = NULL, 
                 random_tree = TRUE, #log_file = "")
                 log_file = "Melanoma/LACEoutput/LACE_output.txt")

saveRDS(object = inference, file = "Melanoma/LACEoutput/inference.rds")

```

We can now visualize the longidutinal clonal tree obtained

```{r}
lt <- longitudinal.tree.plot(inference = inference, label_offset = 3, labels_show = "both")
```

## STEP 4 - Downstream analysis with Seurat

In the latest step we will perform analysis based on the gene expression level of the single cells. To do this we will use the Seurat suite, a collection of functions to handle the analysis of single cell data. The tools are accessible [here](https://satijalab.org/seurat/).

First of all, we load inference result and prepare metadata.

```{r}
inference <- readRDS(file = "Melanoma/LACEoutput/inference.rds")

RUNmetadata <- read.table("Melanoma/downstreamAnalysis/RUNmetadata.txt", header = T, sep = '\t')

# Extracting clone assignment...
run_clones <- data.frame(Run = c(rownames(inference$C[[1]]), 
                             rownames(inference$C[[2]]), 
                             rownames(inference$C[[3]]), 
                             rownames(inference$C[[4]])), 
                     Clone = c(as.numeric(inference$C[[1]]), 
                               as.numeric(inference$C[[2]]), 
                               as.numeric(inference$C[[3]]),
                               as.numeric(inference$C[[4]]))
)

# ... add the assignment to the metadata
RUNmetadata_clones <- merge(x = RUNmetadata, y = run_clones, by = "Run")

saveRDS(RUNmetadata_clones,file="Melanoma/downstreamAnalysis/inference_clones_mapping.rds")

```

Then, we load the gene expression matrix

```{r}
RNA_data <- read.table(file="Melanoma/downstreamAnalysis/GSE116237_scRNAseq_expressionMatrix.txt",
                      header=TRUE, sep=",", row.names=1, check.names=FALSE, stringsAsFactors=FALSE)

RNA_data <- as.matrix(t(RNA_data))
RNA_data_filt <-  RNA_data[RUNmetadata_clones$ExpID,]


saveRDS(RNA_data_filt,file="Melanoma/downstreamAnalysis/RNA_data.rds")
```

In the last pre-processing step we convert ENSEMBL gene ID into Gene Symbol and filter out some genes types

```{r}
library("biomaRt")

RNA_data <- readRDS(file = "Melanoma/downstreamAnalysis/RNA_data.rds")

# Initializing biomaRt
features = sort(unique(colnames(RNA_data)))
mart = useEnsembl(biomart="ensembl",dataset="hsapiens_gene_ensembl")

# Permorming the query
G_list = getBM(filters="ensembl_gene_id",
               attributes= c("ensembl_gene_id","hgnc_symbol","gene_biotype"),
               values=features,
               mart=mart)

# Processing the results
genes_ensample_mapping = G_list[order(G_list[,"ensembl_gene_id"],
                                      G_list[,"hgnc_symbol"],
                                      G_list[,"gene_biotype"]),]

# Removing pseudogenes
gene_biotypes <- unique(genes_ensample_mapping$gene_biotype)
pseudogene_types <- gene_biotypes[grep("pseudogene",gene_biotypes)]
genes_ensample_mapping_filt = genes_ensample_mapping[!(genes_ensample_mapping$gene_biotype %in% pseudogene_types),]

# Removing mitochondrial genes
genes_ensample_mapping_filt = genes_ensample_mapping_filt[!(genes_ensample_mapping_filt$gene_biotype%in%c("Mt_rRNA","Mt_tRNA")),]  
genes_ensample_mapping_filt = genes_ensample_mapping_filt[-grep("MT-",genes_ensample_mapping_filt$hgnc_symbol),]

# Removing features with no hgnc symbol
genes_ensample_mapping_filt = genes_ensample_mapping_filt[genes_ensample_mapping_filt$hgnc_symbol!="",]

# Removing duplicated genes
genes_ensample_mapping_filt = genes_ensample_mapping_filt[!duplicated(genes_ensample_mapping_filt$ensembl_gene_id) &
                                                          !duplicated(genes_ensample_mapping_filt$hgnc_symbol),]


# Saving rds
saveRDS(genes_ensample_mapping_filt, file="Melanoma/downstreamAnalysis/genes_ensample_mapping.rds")

# build final RNA_data
RNA_data_filt = RNA_data[,genes_ensample_mapping_filt$ensembl_gene_id]
colnames(RNA_data_filt) <- genes_ensample_mapping_filt$hgnc_symbol

RNA_data_filt = RNA_data_filt[sort(rownames(RNA_data_filt)),]
RNA_data_filt = RNA_data_filt[,sort(colnames(RNA_data_filt))]

saveRDS(RNA_data_filt,file="Melanoma/downstreamAnalysis/RNA_data_final.rds")

```

#### Initialize Seurat and related object

First of all, we have to initialize the Seurat package

```{r message=FALSE, warning=FALSE}
# Load library
library(dplyr)
library('Seurat')

# Load data

inference_clones_mapping <- readRDS(file="Melanoma/downstreamAnalysis/inference_clones_mapping.rds")
RNA_data <- readRDS(file="Melanoma/downstreamAnalysis/RNA_data_final.rds")

cell_metada <- inference_clones_mapping[,c("Age", "Clone")]
cell_metada$Age[cell_metada$Age == "before treatment"] <-  "T0_BT"
cell_metada$Age[cell_metada$Age == "4d on treatment"] <-  "T1_4d_OT"
cell_metada$Age[cell_metada$Age == "28d on treatment"] <-  "T2_28d_OT"
cell_metada$Age[cell_metada$Age == "57d on treatment"] <-  "T3_57d_OT"
  
cell_metada$Group <- NA
cell_metada$Group[which(cell_metada$Clone == 0)] <- "Root"
cell_metada$Group[which(cell_metada$Clone %in% c(1,2,3))] <- "ARPC2_PRAME_COL1A2"
cell_metada$Group[which(cell_metada$Clone %in% c(4,5))] <- "CCT8_RPL5"
cell_metada$Group[which(cell_metada$Clone == 6) ] <- "HNRNPC"

rownames(cell_metada) <- inference_clones_mapping$ExpID
# Create Seurat object

# we have to traspose the matrix to have genes x cells
melanome <- CreateSeuratObject(counts = t(RNA_data), 
                                    project = "melanome",
                                    meta.data = cell_metada)
```

Seurat provides some useful plot functions, like:

```{r}
VlnPlot(melanome, features = c("nFeature_RNA", "nCount_RNA"), ncol = 2, group.by = "Age")

FeatureScatter(melanome, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = "Age")
```

Now we can normalize data to perform downstream analysis One of the standard approaches consists in dividing the read count by the library size of the given single cell (the total read count), then multiply the results for a scale factor (usually 10\^5); then, log-scale the final values.

All of those steps can be done with a single line of code

```{r}
melanome <- NormalizeData(melanome, normalization.method = "LogNormalize", scale.factor = 10000)
```

We can also focus on a subset of genes considering only the most variable ones. Those genes will be used in the following analyses

```{r warning=FALSE}
melanome <- FindVariableFeatures(melanome, selection.method = "vst", nfeatures = 2000)

LabelPoints(plot = VariableFeaturePlot(melanome), 
            points = head(VariableFeatures(melanome), 10), 
            repel = TRUE)
```

We can further reduce the gene space by computing the PCA. To do this, we have to scale the gene expression

```{r}
all.genes <- rownames(melanome)
melanome <- ScaleData(melanome, features = all.genes)

melanome <- RunPCA(melanome, features = VariableFeatures(object = melanome))

DimPlot(melanome, reduction = "pca", group.by = "Group")

DimHeatmap(melanome, dims = 1:3, balanced = TRUE)

ElbowPlot(melanome)

#saveRDS(object = melanome, file = "Melanoma/downstreamAnalysis/seurat_melanome.rds")
```

Another common analysis regards the cell clustering. Seurat allows us to use different approaches. However, the most used is a graph-based clustering approach method (such as Leiden or Louvain)

```{r}
#library(Seurat)
#melanome <- readRDS(file = "Melanoma/downstreamAnalysis/seurat_melanome.rds")

melanome <- FindNeighbors(melanome, dims = 1:6, nn.method = "rann")
melanome <- FindClusters(melanome, resolution = 0.125)
```

We can visualize the clustering results using the umap method and compare it with our metadata

```{r}
melanome <- RunUMAP(melanome, dims = 1:6)


DimPlot(melanome, reduction = "umap")

DimPlot(melanome, reduction = "umap", split.by = "Age")

```

So, we can observe that there are a cluster present before the treatment and when the tumor relapse.

Finally, we can obtain genes that are differential expressed in different cell groups such as (Time points, Seurat clusters or genetic clones)

```{r}
library(dplyr)
Idents(melanome) <- melanome$Age
TimePoint_markers <- FindAllMarkers(melanome, 
                                    only.pos = T, 
                                    test.use = "wilcox", 
                                    min.pct = 0.3)

TP_top10m <-  TimePoint_markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)
print(TP_top10m[order(TP_top10m$avg_log2FC, decreasing = T), ])
```
